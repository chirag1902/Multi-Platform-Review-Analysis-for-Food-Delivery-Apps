[
  {
    "objectID": "notebooks/Zero_Shot_Classification.html",
    "href": "notebooks/Zero_Shot_Classification.html",
    "title": "Zero Shot Classification of Reviews",
    "section": "",
    "text": "C:\\Users\\chira\\AppData\\Local\\Temp\\ipykernel_11780\\2217802626.py:10: FutureWarning:\n\n\n\nPassing `palette` without assigning `hue` is deprecated and will be removed in v0.14.0. Assign the `x` variable to `hue` and set `legend=False` for the same effect.\n\n\n\n\n\n\n\n\n\n\n\nReliable service‚Äù stands out as the most frequently praised feature. Customer service and ease of use follow as other key drivers of positive sentiment."
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#top-5-labels-for-positive-sentiment",
    "href": "notebooks/Zero_Shot_Classification.html#top-5-labels-for-positive-sentiment",
    "title": "Zero Shot Classification of Reviews",
    "section": "",
    "text": "C:\\Users\\chira\\AppData\\Local\\Temp\\ipykernel_11780\\2217802626.py:10: FutureWarning:\n\n\n\nPassing `palette` without assigning `hue` is deprecated and will be removed in v0.14.0. Assign the `x` variable to `hue` and set `legend=False` for the same effect.\n\n\n\n\n\n\n\n\n\n\n\nReliable service‚Äù stands out as the most frequently praised feature. Customer service and ease of use follow as other key drivers of positive sentiment."
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#top-5-labels-for-negative-sentiment",
    "href": "notebooks/Zero_Shot_Classification.html#top-5-labels-for-negative-sentiment",
    "title": "Zero Shot Classification of Reviews",
    "section": "Top 5 Labels for Negative Sentiment",
    "text": "Top 5 Labels for Negative Sentiment\n\n\nCode\n# Negative sentiment\nnegative_labels = top_label_counts[top_label_counts['sentiment'].str.lower() == 'negative']\nnegative_top5 = negative_labels.sort_values(by='count', ascending=False).head(5)\n\nplt.figure(figsize=(10,5))\nsns.barplot(x='top_label', y='count', data=negative_top5, palette=\"Set2\")\nplt.title('Top 5 Top Labels - Negative Sentiment')\nplt.xlabel('Top Label')\nplt.ylabel('Count')\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()\n\n\nC:\\Users\\chira\\AppData\\Local\\Temp\\ipykernel_11780\\3209300340.py:7: FutureWarning:\n\n\n\nPassing `palette` without assigning `hue` is deprecated and will be removed in v0.14.0. Assign the `x` variable to `hue` and set `legend=False` for the same effect.\n\n\n\n\n\n\n\n\n\n\n\nUnresponsive customer service‚Äù dominates negative feedback. Price-related concerns and delivery issues (missing items, wait times) are also significant."
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#top-5-labels-for-neutral-sentiment",
    "href": "notebooks/Zero_Shot_Classification.html#top-5-labels-for-neutral-sentiment",
    "title": "Zero Shot Classification of Reviews",
    "section": "Top 5 Labels for Neutral Sentiment",
    "text": "Top 5 Labels for Neutral Sentiment\n\n\nCode\n# Neutral sentiment\nneutral_labels = top_label_counts[top_label_counts['sentiment'].str.lower() == 'neutral']\nneutral_top5 = neutral_labels.sort_values(by='count', ascending=False).head(5)\n\nplt.figure(figsize=(10,5))\nsns.barplot(x='top_label', y='count', data=neutral_top5, palette=\"Set2\")\nplt.title('Top 5 Top Labels - Neutral Sentiment')\nplt.xlabel('Top Label')\nplt.ylabel('Count')\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()\n\n\nC:\\Users\\chira\\AppData\\Local\\Temp\\ipykernel_11780\\200243279.py:7: FutureWarning:\n\n\n\nPassing `palette` without assigning `hue` is deprecated and will be removed in v0.14.0. Assign the `x` variable to `hue` and set `legend=False` for the same effect.\n\n\n\n\n\n\n\n\n\n\n\nFeedback reflects variability, with ‚Äúmixed experiences‚Äù and ‚Äúinconsistent service‚Äù being most mentioned. Neutral sentiments often reflect tempered expectations or situational outcomes."
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#ubereats---top-5-labels-for-positive-sentiments",
    "href": "notebooks/Zero_Shot_Classification.html#ubereats---top-5-labels-for-positive-sentiments",
    "title": "Zero Shot Classification of Reviews",
    "section": "UberEats - Top 5 Labels for Positive Sentiments",
    "text": "UberEats - Top 5 Labels for Positive Sentiments\n\n\nCode\n# Filter UberEats reviews\nubereats = combined_df[combined_df['app_name'] == 'UberEats']\n\n# Filter Positive sentiment\npositive_df = ubereats[ubereats['sentiment'].str.lower() == 'positive']\n\n# Top 5 labels\npositive_top5 = positive_df['top_label'].value_counts().head(5)\n\n# Plot\nplt.figure(figsize=(8,5))\nsns.barplot(x=positive_top5.index, y=positive_top5.values, palette='Set2')\nplt.title('Top 5 Labels for UberEats - Positive Sentiment')\nplt.xlabel('Top Label')\nplt.ylabel('Count')\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()\n\n\nC:\\Users\\chira\\AppData\\Local\\Temp\\ipykernel_11780\\3373619653.py:13: FutureWarning:\n\n\n\nPassing `palette` without assigning `hue` is deprecated and will be removed in v0.14.0. Assign the `x` variable to `hue` and set `legend=False` for the same effect.\n\n\n\n\n\n\n\n\n\n\n\nUberEats is positively recognized for reliable service and good customer support. ‚ÄúGood discounts‚Äù also appear, showing promotional offers impact user satisfaction."
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#ubereats---top-5-labels-for-negative-sentiments",
    "href": "notebooks/Zero_Shot_Classification.html#ubereats---top-5-labels-for-negative-sentiments",
    "title": "Zero Shot Classification of Reviews",
    "section": "UberEats - Top 5 Labels for Negative Sentiments",
    "text": "UberEats - Top 5 Labels for Negative Sentiments\n\n\nCode\n# Filter Negative sentiment\nnegative_df = ubereats[ubereats['sentiment'].str.lower() == 'negative']\n\n# Top 5 labels\nnegative_top5 = negative_df['top_label'].value_counts().head(5)\n\n# Plot\nplt.figure(figsize=(8,5))\nsns.barplot(x=negative_top5.index, y=negative_top5.values, palette='Set2')\nplt.title('Top 5 Labels for UberEats - Negative Sentiment')\nplt.xlabel('Top Label')\nplt.ylabel('Count')\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()\n\n\nC:\\Users\\chira\\AppData\\Local\\Temp\\ipykernel_11780\\719617373.py:10: FutureWarning:\n\n\n\nPassing `palette` without assigning `hue` is deprecated and will be removed in v0.14.0. Assign the `x` variable to `hue` and set `legend=False` for the same effect.\n\n\n\n\n\n\n\n\n\n\n\n‚ÄúUnresponsive customer service‚Äù is the top concern among UberEats users. Other recurring complaints include pricing and delivery fulfillment issues."
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#ubereats---top-5-labels-for-neutral-sentiments",
    "href": "notebooks/Zero_Shot_Classification.html#ubereats---top-5-labels-for-neutral-sentiments",
    "title": "Zero Shot Classification of Reviews",
    "section": "UberEats - Top 5 Labels for Neutral Sentiments",
    "text": "UberEats - Top 5 Labels for Neutral Sentiments\n\n\nC:\\Users\\chira\\AppData\\Local\\Temp\\ipykernel_11780\\3615030921.py:10: FutureWarning:\n\n\n\nPassing `palette` without assigning `hue` is deprecated and will be removed in v0.14.0. Assign the `x` variable to `hue` and set `legend=False` for the same effect.\n\n\n\n\n\n\n\n\n\n\n\n‚ÄúInconsistent service‚Äù and ‚Äúmixed experiences‚Äù dominate the neutral feedback for UberEats. Sentiment here indicates fluctuating user experiences without strong positive or negative lean."
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#ubereats---interactive-top-5-labels",
    "href": "notebooks/Zero_Shot_Classification.html#ubereats---interactive-top-5-labels",
    "title": "Zero Shot Classification of Reviews",
    "section": "UberEats - Interactive Top 5 Labels",
    "text": "UberEats - Interactive Top 5 Labels\n\n\nCode\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\n# Prepare unique combinations\ndata_sources = ['Google Play', 'Reddit', 'App Store']\nsentiments = ['Positive', 'Neutral', 'Negative']\n\n# Store traces and buttons\nfig = go.Figure()\nbuttons = []\nvisibility = []\n\n# Track trace index\ntrace_idx = 0\n\nfor data_source in data_sources:\n    for sentiment in sentiments:\n        source_df = ubereats[ubereats['data_source'] == data_source]\n        source_sentiment_df = source_df[source_df['sentiment'] == sentiment]\n        top5_labels = source_sentiment_df['top_label'].value_counts().head(5)\n\n        if not top5_labels.empty:\n            trace = go.Bar(\n                x=top5_labels.index,\n                y=top5_labels.values,\n                name=f'{data_source} - {sentiment}',\n                visible=False,\n                marker_color=px.colors.qualitative.Set2\n            )\n            fig.add_trace(trace)\n            visibility.append((data_source, sentiment, trace_idx))\n            trace_idx += 1\n\n# Add dropdown buttons\nfor i, (ds, s, idx) in enumerate(visibility):\n    vis = [False] * len(visibility)\n    vis[idx] = True\n    button = dict(\n        label=f'{ds} - {s}',\n        method='update',\n        args=[{'visible': vis},\n              {'title': f'UberEats - {ds} - {s} - Top 5 Labels'}]\n    )\n    buttons.append(button)\n\nfig.update_layout(\n    updatemenus=[\n        dict(\n            buttons=buttons,\n            direction='down',\n            showactive=True,\n            x=0.5,\n            xanchor='center',\n            y=1.2,\n            yanchor='top'\n        )\n    ],\n    title='UberEats - Interactive Top 5 Labels',\n    xaxis_title='Top Label',\n    yaxis_title='Count'\n)\n\nfig.show()"
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#for-ubereats---for-each-data_source-ignoring-sentiment-top-5-labels",
    "href": "notebooks/Zero_Shot_Classification.html#for-ubereats---for-each-data_source-ignoring-sentiment-top-5-labels",
    "title": "Zero Shot Classification of Reviews",
    "section": "For UberEats - for each data_source (ignoring sentiment), top 5 labels",
    "text": "For UberEats - for each data_source (ignoring sentiment), top 5 labels\n\n\nCode\nimport plotly.graph_objects as go\nimport plotly.express as px\n\n# List of data sources\ndata_sources = ['Google Play', 'Reddit', 'App Store']\n\n# Initialize figure\nfig = go.Figure()\nbuttons = []\nvisibility = []\n\n# Add one bar trace per data source (initially hidden)\nfor idx, data_source in enumerate(data_sources):\n    source_df = ubereats[ubereats['data_source'] == data_source]\n    top5_labels = source_df['top_label'].value_counts().head(5)\n\n    trace = go.Bar(\n        x=top5_labels.index,\n        y=top5_labels.values,\n        name=data_source,\n        visible=(idx == 0),  # Show only the first one initially\n        marker_color=px.colors.qualitative.Set2\n    )\n    fig.add_trace(trace)\n\n# Create dropdown buttons\nfor i, ds in enumerate(data_sources):\n    vis = [False] * len(data_sources)\n    vis[i] = True\n    buttons.append(dict(\n        label=ds,\n        method='update',\n        args=[{'visible': vis},\n              {'title': f'UberEats - {ds} - Top 5 Labels (All Sentiments)'}]\n    ))\n\n# Final layout\nfig.update_layout(\n    updatemenus=[dict(\n        buttons=buttons,\n        direction='down',\n        showactive=True,\n        x=0.5,\n        xanchor='center',\n        y=1.2,\n        yanchor='top'\n    )],\n    title=f'UberEats - {data_sources[0]} - Top 5 Labels (All Sentiments)',\n    xaxis_title='Top Label',\n    yaxis_title='Count'\n)\n\nfig.show()"
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#for-ubereats---overall-ignoring-sentiment-and-datasource-top-5-labels",
    "href": "notebooks/Zero_Shot_Classification.html#for-ubereats---overall-ignoring-sentiment-and-datasource-top-5-labels",
    "title": "Zero Shot Classification of Reviews",
    "section": "For UberEats - overall (ignoring sentiment and datasource), top 5 labels",
    "text": "For UberEats - overall (ignoring sentiment and datasource), top 5 labels\n\n\nCode\ntop5_labels = ubereats['top_label'].value_counts().head(5)\n\nplt.figure(figsize=(8,5))\nsns.barplot(x=top5_labels.index, y=top5_labels.values, palette='Set2')\nplt.title('UberEats - Top 5 Labels Overall')\nplt.xlabel('Top Label')\nplt.ylabel('Count')\nplt.xticks(rotation=45)\nplt.tight_layout()\nplt.show()\n\n\nC:\\Users\\chira\\AppData\\Local\\Temp\\ipykernel_11780\\233713667.py:5: FutureWarning:\n\n\n\nPassing `palette` without assigning `hue` is deprecated and will be removed in v0.14.0. Assign the `x` variable to `hue` and set `legend=False` for the same effect.\n\n\n\n\n\n\n\n\n\n\n\n‚ÄúUnresponsive customer service‚Äù is the most frequent concern, with ‚Äúreliable service‚Äù following as a positive counterpoint. Mixed service perceptions dominate the narrative, showing a polarized customer experience."
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#doordash---sentiment---top-5-labels",
    "href": "notebooks/Zero_Shot_Classification.html#doordash---sentiment---top-5-labels",
    "title": "Zero Shot Classification of Reviews",
    "section": "DoorDash - Sentiment - Top 5 Labels",
    "text": "DoorDash - Sentiment - Top 5 Labels\n\n\nCode\nimport plotly.graph_objects as go\nimport plotly.express as px\n\n# Filter DoorDash data\ndoordash = combined_df[combined_df['app_name'] == 'DoorDash']\nsentiments = ['Positive', 'Neutral', 'Negative']\n\n# Create figure\nfig = go.Figure()\nbuttons = []\n\n# Add one bar trace per sentiment\nfor idx, sentiment in enumerate(sentiments):\n    sentiment_df = doordash[doordash['sentiment'] == sentiment]\n    top5 = sentiment_df['top_label'].value_counts().head(5)\n\n    fig.add_trace(go.Bar(\n        x=top5.index,\n        y=top5.values,\n        name=sentiment,\n        visible=(idx == 0),  # Show first sentiment by default\n        marker_color=px.colors.qualitative.Set2\n    ))\n\n# Create dropdown buttons\nfor i, sentiment in enumerate(sentiments):\n    vis = [False] * len(sentiments)\n    vis[i] = True\n    buttons.append(dict(\n        label=sentiment,\n        method='update',\n        args=[{'visible': vis},\n              {'title': f'DoorDash - {sentiment} Sentiment - Top 5 Labels'}]\n    ))\n\n# Final layout\nfig.update_layout(\n    updatemenus=[dict(\n        buttons=buttons,\n        direction='down',\n        showactive=True,\n        x=0.5,\n        xanchor='center',\n        y=1.2,\n        yanchor='top'\n    )],\n    title='DoorDash - Positive Sentiment - Top 5 Labels',\n    xaxis_title='Top Label',\n    yaxis_title='Count'\n)\n\nfig.show()"
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#doordash---data-sources---top-5-labels",
    "href": "notebooks/Zero_Shot_Classification.html#doordash---data-sources---top-5-labels",
    "title": "Zero Shot Classification of Reviews",
    "section": "DoorDash - Data Sources - Top 5 Labels",
    "text": "DoorDash - Data Sources - Top 5 Labels"
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#doordash---google-play---top-5-labels-all-sentiments",
    "href": "notebooks/Zero_Shot_Classification.html#doordash---google-play---top-5-labels-all-sentiments",
    "title": "Zero Shot Classification of Reviews",
    "section": "DoorDash - Google Play - Top 5 Labels (All Sentiments)",
    "text": "DoorDash - Google Play - Top 5 Labels (All Sentiments)"
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#doordash---overall-top-5-labels",
    "href": "notebooks/Zero_Shot_Classification.html#doordash---overall-top-5-labels",
    "title": "Zero Shot Classification of Reviews",
    "section": "DoorDash - Overall Top 5 Labels",
    "text": "DoorDash - Overall Top 5 Labels\n\n\nC:\\Users\\chira\\AppData\\Local\\Temp\\ipykernel_11780\\1556962487.py:4: FutureWarning:\n\n\n\nPassing `palette` without assigning `hue` is deprecated and will be removed in v0.14.0. Assign the `x` variable to `hue` and set `legend=False` for the same effect.\n\n\n\n\n\n\n\n\n\n\n\nSimilar to UberEats, DoorDash users frequently report ‚Äúunresponsive customer service‚Äù and value ‚Äúreliable service.‚Äù A notable portion of feedback also reflects inconsistency and mixed experiences."
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#grubhub---sentiment---top-5-labels",
    "href": "notebooks/Zero_Shot_Classification.html#grubhub---sentiment---top-5-labels",
    "title": "Zero Shot Classification of Reviews",
    "section": "GrubHub - Sentiment - Top 5 Labels",
    "text": "GrubHub - Sentiment - Top 5 Labels"
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#grubhub---data-sources---sentiment---top-5-labels",
    "href": "notebooks/Zero_Shot_Classification.html#grubhub---data-sources---sentiment---top-5-labels",
    "title": "Zero Shot Classification of Reviews",
    "section": "GrubHub - Data Sources - Sentiment - Top 5 Labels",
    "text": "GrubHub - Data Sources - Sentiment - Top 5 Labels"
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#grubhub---data_source---top-5-labels-all-sentiments",
    "href": "notebooks/Zero_Shot_Classification.html#grubhub---data_source---top-5-labels-all-sentiments",
    "title": "Zero Shot Classification of Reviews",
    "section": "GrubHub - Data_Source - Top 5 Labels (All Sentiments)",
    "text": "GrubHub - Data_Source - Top 5 Labels (All Sentiments)"
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#grubhub---overall-top-5-labels",
    "href": "notebooks/Zero_Shot_Classification.html#grubhub---overall-top-5-labels",
    "title": "Zero Shot Classification of Reviews",
    "section": "GrubHub - Overall Top 5 Labels",
    "text": "GrubHub - Overall Top 5 Labels\n\n\nC:\\Users\\chira\\AppData\\Local\\Temp\\ipykernel_11780\\3418218262.py:4: FutureWarning:\n\n\n\nPassing `palette` without assigning `hue` is deprecated and will be removed in v0.14.0. Assign the `x` variable to `hue` and set `legend=False` for the same effect.\n\n\n\n\n\n\n\n\n\n\n\nGrubHub shares similar patterns with its competitors‚Äîcustomer service issues top the list. ‚ÄúReliable service‚Äù and ‚Äúmixed experiences‚Äù suggest a divided but slightly less vocal user base."
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#google-play---sentiment---top-5-labels",
    "href": "notebooks/Zero_Shot_Classification.html#google-play---sentiment---top-5-labels",
    "title": "Zero Shot Classification of Reviews",
    "section": "Google Play - Sentiment - Top 5 Labels",
    "text": "Google Play - Sentiment - Top 5 Labels"
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#google-play---overall-top-5-labels-all-sentiments",
    "href": "notebooks/Zero_Shot_Classification.html#google-play---overall-top-5-labels-all-sentiments",
    "title": "Zero Shot Classification of Reviews",
    "section": "Google Play - Overall Top 5 Labels (All Sentiments)",
    "text": "Google Play - Overall Top 5 Labels (All Sentiments)\n\n\nC:\\Users\\chira\\AppData\\Local\\Temp\\ipykernel_11780\\3286387572.py:4: FutureWarning:\n\n\n\nPassing `palette` without assigning `hue` is deprecated and will be removed in v0.14.0. Assign the `x` variable to `hue` and set `legend=False` for the same effect.\n\n\n\n\n\n\n\n\n\n\n\nOn Google Play, feedback on customer service is most dominant, both negatively (‚Äúunresponsive‚Äù) and positively (‚Äúgood‚Äù). Usability (‚Äúeasy to use‚Äù) and pricing also influence customer sentiment significantly."
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#reddit---sentiment---top-5-labels",
    "href": "notebooks/Zero_Shot_Classification.html#reddit---sentiment---top-5-labels",
    "title": "Zero Shot Classification of Reviews",
    "section": "Reddit - Sentiment - Top 5 Labels",
    "text": "Reddit - Sentiment - Top 5 Labels"
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#reddit---overall-top-5-labels-all-sentiments",
    "href": "notebooks/Zero_Shot_Classification.html#reddit---overall-top-5-labels-all-sentiments",
    "title": "Zero Shot Classification of Reviews",
    "section": "Reddit - Overall Top 5 Labels (All Sentiments)",
    "text": "Reddit - Overall Top 5 Labels (All Sentiments)\n\n\nC:\\Users\\chira\\AppData\\Local\\Temp\\ipykernel_11780\\1014653831.py:4: FutureWarning:\n\n\n\nPassing `palette` without assigning `hue` is deprecated and will be removed in v0.14.0. Assign the `x` variable to `hue` and set `legend=False` for the same effect.\n\n\n\n\n\n\n\n\n\n\n\nReddit discussions heavily critique customer service, followed by comments on inconsistent and mixed experiences. Issues like missing items and driver problems highlight operational gaps."
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#app-store---sentiment---top-5-labels",
    "href": "notebooks/Zero_Shot_Classification.html#app-store---sentiment---top-5-labels",
    "title": "Zero Shot Classification of Reviews",
    "section": "App Store - Sentiment - Top 5 Labels",
    "text": "App Store - Sentiment - Top 5 Labels"
  },
  {
    "objectID": "notebooks/Zero_Shot_Classification.html#app-store---overall-top-5-labels-all-sentiments",
    "href": "notebooks/Zero_Shot_Classification.html#app-store---overall-top-5-labels-all-sentiments",
    "title": "Zero Shot Classification of Reviews",
    "section": "App Store - Overall Top 5 Labels (All Sentiments)",
    "text": "App Store - Overall Top 5 Labels (All Sentiments)\n\n\nC:\\Users\\chira\\AppData\\Local\\Temp\\ipykernel_11780\\1882811874.py:4: FutureWarning:\n\n\n\nPassing `palette` without assigning `hue` is deprecated and will be removed in v0.14.0. Assign the `x` variable to `hue` and set `legend=False` for the same effect.\n\n\n\n\n\n\n\n\n\n\n\n‚ÄúUnresponsive customer service‚Äù overwhelmingly dominates App Store feedback. Other concerns like long wait times and delivery issues appear far less frequently, indicating focused dissatisfaction."
  },
  {
    "objectID": "notebooks/Sentiment_Analysis.html#sentiment-distribution-for-apps",
    "href": "notebooks/Sentiment_Analysis.html#sentiment-distribution-for-apps",
    "title": "Sentiment Analysis of Reviews",
    "section": "Sentiment Distribution for Apps",
    "text": "Sentiment Distribution for Apps\n\nSentiment Distribution for UberEats\n\n\nCode\nplot_sentiment_distribution('UberEats')\n\n\n\n\n\n\n\n\n\n\n\nSentiment Distribution for DoorDash\n\n\nCode\nplot_sentiment_distribution('DoorDash')\n\n\n\n\n\n\n\n\n\n\n\nSentiment Distribution for Grubhub\n\n\nCode\nplot_sentiment_distribution('GrubHub')\n\n\n\n\n\n\n\n\n\nThe donut chart above illustrates the sentiment distribution of customer reviews for food delivery apps. Each segment of the chart represents the percentage of reviews that are classified as Positive, Neutral, or Negative. This visualization offers a clear and comparative view of user satisfaction levels, highlighting how customer perception varies across different apps."
  },
  {
    "objectID": "notebooks/Sentiment_Analysis.html#sentiment-distribution-for-data-sources",
    "href": "notebooks/Sentiment_Analysis.html#sentiment-distribution-for-data-sources",
    "title": "Sentiment Analysis of Reviews",
    "section": "Sentiment Distribution for Data Sources",
    "text": "Sentiment Distribution for Data Sources\n\n\nCode\n# ---------------------------\n# Clean your data\n# ---------------------------\ndf_combined['sentiment'] = df_combined['sentiment'].str.lower()\ndf_combined['data_source'] = df_combined['data_source'].str.strip().str.title()\n\n# ---------------------------\n# Define sentiment colors\n# ---------------------------\nsentiment_colors = {\n    'neutral': '#90EE90',\n    'positive': '#32CD32',\n    'negative': '#006400',\n}\n\n# ---------------------------\n# Setup\n# ---------------------------\nsources = sorted(df_combined['data_source'].unique())\nsentiments = ['neutral', 'positive', 'negative']\nfig = go.Figure()\nbuttons = []\n\n# Create a donut chart for each data source\nfor i, src in enumerate(sources):\n    filtered_df = df_combined[df_combined['data_source'] == src]\n    counts = filtered_df['sentiment'].value_counts()\n    values = [counts.get(s, 0) for s in sentiments]\n    colors = [sentiment_colors[s] for s in sentiments]\n\n    # Add a pie (donut) chart trace for this source\n    fig.add_trace(go.Pie(\n        labels=sentiments,\n        values=values,\n        hole=0.5,\n        marker=dict(colors=colors),\n        name=src,\n        visible=(i == 0),\n        textinfo='percent+label',\n        insidetextorientation='radial'\n    ))\n\n    # Create button to toggle visibility\n    buttons.append(dict(\n        label=src,\n        method=\"update\",\n        args=[{\"visible\": [j == i for j in range(len(sources))]},\n              {\"title\": f\"Overall Sentiment Distribution for {src}\"}]\n    ))\n\n# ---------------------------\n# Add dropdown menu\n# ---------------------------\nfig.update_layout(\n    updatemenus=[dict(\n        type=\"dropdown\",\n        buttons=buttons,\n        direction=\"down\",\n        x=0.1,\n        y=1.15\n    )],\n    title=f\"Overall Sentiment Distribution for {sources[0]}\",\n    height=500\n)\n\nfig.show()\n\n\n        \n        \n        \n\n\n                            \n                                            \n\n\nThe donut chart visualizes the sentiment distribution for a selected app across various review platforms.Each segment of the chart represents the percentage of reviews labeled as Positive, Neutral, or Negative. This allows for comparison of user sentiment trends across different communities and platforms where the app is reviewed."
  },
  {
    "objectID": "notebooks/Sentiment_Analysis.html#top-10-upvoted-reviews-for-apps",
    "href": "notebooks/Sentiment_Analysis.html#top-10-upvoted-reviews-for-apps",
    "title": "Sentiment Analysis of Reviews",
    "section": "Top 10 Upvoted Reviews for Apps",
    "text": "Top 10 Upvoted Reviews for Apps\n\n\nCode\ndf_combined['sentiment'] = df_combined['sentiment'].str.capitalize()\ndf_combined['review'] = df_combined['review'].astype(str)\n\n# Define colors\nsentiment_colors = {\n    'Positive': 'green',\n    'Negative': 'red',\n    'Neutral': 'blue'\n}\n\n# Apps to show\napps = ['UberEats', 'DoorDash', 'GrubHub']\n\n# Build the figure\nfig = go.Figure()\nbuttons = []\n\nfor i, app in enumerate(apps):\n    app_df = df_combined[df_combined['app_name'] == app]\n    top_10 = app_df.sort_values(by='upvote_count', ascending=False).head(10)\n    if top_10.empty:\n        continue\n\n    # Shorten long reviews\n    review_labels = top_10['review'].apply(lambda x: x[:80] + '...' if len(x) &gt; 80 else x)\n    bar_colors = top_10['sentiment'].map(sentiment_colors).fillna('gray')\n\n    fig.add_trace(go.Bar(\n        x=top_10['upvote_count'],\n        y=review_labels,\n        orientation='h',\n        marker_color=bar_colors,\n        name=app,\n        visible=(i == 0),\n        hovertext=top_10['review'],\n    ))\n\n    # Dropdown button to toggle visibility\n    buttons.append(dict(\n        label=app,\n        method=\"update\",\n        args=[\n            {\"visible\": [j == i for j in range(len(apps))]},\n            {\"title\": f\"Top 10 Upvoted Reviews for {app}\"}\n        ]\n    ))\n\n# Final layout\nfig.update_layout(\n    title=f\"Top 10 Upvoted Reviews for {apps[0]} \",\n    xaxis_title=\"Upvote Count\",\n    yaxis_title=\"Review\",\n    yaxis=dict(autorange='reversed'),\n    height=600,\n    updatemenus=[dict(\n        type=\"dropdown\",\n        buttons=buttons,\n        x=0.1,\n        y=1.15\n    )]\n)\n\nfig.show()\n\n\n                            \n                                            \n\n\nThis horizontal bar chart displays the top 10 most upvoted customer reviews for a selected food delivery app. Each bar is color-coded by sentiment‚Äîblue for Neutral, red for Negative, and green (if present) for Positive‚Äîproviding a quick visual reference to the tone of each review. The dropdown allows switching between UberEats, DoorDash, and GrubHub for comparison."
  },
  {
    "objectID": "notebooks/Sentiment_Analysis.html#top-10-upvoted-reviews-for-data-sources",
    "href": "notebooks/Sentiment_Analysis.html#top-10-upvoted-reviews-for-data-sources",
    "title": "Sentiment Analysis of Reviews",
    "section": "Top 10 Upvoted Reviews for Data Sources",
    "text": "Top 10 Upvoted Reviews for Data Sources\n\n\nCode\n# -----------------------------\n# Clean data\n# -----------------------------\ndf_combined['sentiment'] = df_combined['sentiment'].str.capitalize()\ndf_combined['review'] = df_combined['review'].astype(str)\ndf_combined['data_source'] = df_combined['data_source'].str.strip().str.title()\n\n# -----------------------------\n# Define sentiment colors\n# -----------------------------\nsentiment_colors = {\n    'Positive': 'green',\n    'Negative': 'red',\n    'Neutral': 'blue'\n}\n\n# -----------------------------\n# Limit to Reddit and Google Play\n# -----------------------------\nvalid_sources = ['Reddit', 'Google Play']\nsources = [s for s in valid_sources if s in df_combined['data_source'].unique()]\n\n# -----------------------------\n# Build Plotly figure\n# -----------------------------\nfig = go.Figure()\nbuttons = []\n\nfor i, source in enumerate(sources):\n    source_data = df_combined[df_combined['data_source'] == source]\n    top_10 = source_data.sort_values(by='upvote_count', ascending=False).head(10)\n\n    review_labels = top_10['review'].apply(lambda x: x[:80] + '...' if len(x) &gt; 80 else x)\n    bar_colors = top_10['sentiment'].map(sentiment_colors).fillna('gray')\n\n    fig.add_trace(go.Bar(\n        x=top_10['upvote_count'],\n        y=review_labels,\n        orientation='h',\n        marker_color=bar_colors,\n        name=source,\n        visible=(i == 0),\n        hovertext=top_10['review'],\n    ))\n\n    buttons.append(dict(\n        label=source,\n        method=\"update\",\n        args=[\n            {\"visible\": [j == i for j in range(len(sources))]},\n            {\"title\": f\"Top 10 Upvoted Reviews for {source}\"}\n        ]\n    ))\n\n# -----------------------------\n# Final layout\n# -----------------------------\nfig.update_layout(\n    title=f\"Top 10 Upvoted Reviews for {sources[0]}\" if sources else \"No Data\",\n    xaxis_title=\"Upvote Count\",\n    yaxis_title=\"Review\",\n    yaxis=dict(autorange='reversed'),\n    height=600,\n    updatemenus=[dict(\n        type=\"dropdown\",\n        buttons=buttons,\n        x=0.1,\n        y=1.15\n    )]\n)\n\nfig.show()\n\n\n                            \n                                            \n\n\nThis horizontal bar chart displays the top 10 most upvoted customer reviews from the selected data source. Users can switch between platforms such as Google Play and Reddit using the dropdown. Each bar represents a highly upvoted review and is color-coded by sentiment ‚Äî red for Negative, blue for Neutral, and green for Positive. This plot highlights not only the most talked-about experiences on each platform but also the general sentiment users express toward food delivery apps depending on where the review was posted."
  },
  {
    "objectID": "notebooks/EDA.html",
    "href": "notebooks/EDA.html",
    "title": "Exploratory Data Analysis of Reviews",
    "section": "",
    "text": "Exploratory Data Analysis\n\n\nCode\nimport plotly.graph_objects as go\n\n# --------------------------\n# Clean your data\n# --------------------------\ndf_combined['review'] = df_combined['review'].astype(str)\ndf_combined['data_source'] = df_combined['data_source'].astype(str).str.strip().str.title()\ndf_combined['app_name'] = df_combined['app_name'].astype(str).str.strip().str.capitalize()\n\n# --------------------------\n# Define variables\n# --------------------------\ntarget_apps = ['Ubereats', 'Doordash', 'Grubhub']\ntarget_sources = ['Reddit', 'Google Play', 'App Store']\ncolors_app = ['green', 'red', 'orange']\ncolors_source = ['red', 'green', 'blue']\n\n# --------------------------\n# Create traces for data sources\n# --------------------------\nsource_traces = []\nfor source in sorted(df_combined['data_source'].unique()):\n    df_filtered = df_combined[df_combined['data_source'] == source]\n    counts = df_filtered['app_name'].value_counts().to_dict()\n    x_vals = [counts.get(app, 0) for app in target_apps]\n    source_traces.append(go.Bar(\n        x=x_vals,\n        y=target_apps,\n        orientation='h',\n        marker_color=colors_app,\n        name=source,\n        visible=False\n    ))\n\n# --------------------------\n# Create traces for app names\n# --------------------------\napp_traces = []\nfor app in sorted(df_combined['app_name'].unique()):\n    df_filtered = df_combined[df_combined['app_name'] == app]\n    counts = df_filtered['data_source'].value_counts().to_dict()\n    x_vals = [counts.get(src, 0) for src in target_sources]\n    app_traces.append(go.Bar(\n        x=x_vals,\n        y=target_sources,\n        orientation='h',\n        marker_color=colors_source,\n        name=app,\n        visible=False\n    ))\n\n# Combine traces\nall_traces = source_traces + app_traces\n\n# --------------------------\n# Create dropdown buttons\n# --------------------------\nbuttons = []\n\n# Buttons for data sources\nfor i, source in enumerate(sorted(df_combined['data_source'].unique())):\n    visibility = [False] * len(all_traces)\n    visibility[i] = True\n    buttons.append(dict(\n        label=f\"Source: {source}\",\n        method='update',\n        args=[{'visible': visibility},\n              {'title': f\"Review Counts in {source}\",\n               'xaxis': {'title': 'Number of Reviews'},\n               'yaxis': {'title': 'App'}}]\n    ))\n\n# Buttons for app names\nfor j, app in enumerate(sorted(df_combined['app_name'].unique())):\n    visibility = [False] * len(all_traces)\n    visibility[len(source_traces) + j] = True\n    buttons.append(dict(\n        label=f\"App: {app}\",\n        method='update',\n        args=[{'visible': visibility},\n              {'title': f\"{app} Review Counts by Data Source\",\n               'xaxis': {'title': 'Number of Reviews'},\n               'yaxis': {'title': 'Data Source'}}]\n    ))\n\n# --------------------------\n# Build the figure\n# --------------------------\nfig = go.Figure(data=all_traces)\n\n# Set initial trace visible\nfig.data[0].visible = True\n\nfig.update_layout(\n    updatemenus=[dict(\n        active=0,\n        buttons=buttons,\n        direction='down',\n        x=0.5,\n        xanchor='center',\n        y=1.2,\n        yanchor='top'\n    )],\n    title=\"Review Counts in \" + sorted(df_combined['data_source'].unique())[0],\n    xaxis_title='Number of Reviews',\n    yaxis_title='App',\n    height=500,\n    plot_bgcolor='white'\n)\n\nfig.show()\n\n\n\n\n\nThis dashboard presents a side-by-side comparison of review volumes by app and by data source.\nThe left chart displays the total number of reviews submitted for each food delivery app (UberEats, DoorDash, GrubHub) within the selected data source (e.g., Reddit).\nThe right chart highlights how many reviews a selected app has received across multiple platforms (App Store, Google Play, Reddit).\nThis dual-panel visualization helps assess both platform-specific popularity and app-level customer engagement, offering insights into where users are most vocal and which platforms generate the most feedback.\n\n\nCode\n# Prepare data\ndf_combined1 = df_combined.copy()\ndf_combined1['review_datetime'] = pd.to_datetime(df_combined1['review_datetime'], errors='coerce')\ndf_combined1['month_year'] = df_combined1['review_datetime'].dt.to_period('M').astype(str)\n\n# Group by app and month\nmonthly_reviews = df_combined1.groupby(['app_name', 'month_year']).size().reset_index(name='review_count')\n\n# Create Plotly line plot\nfig = px.line(\n    monthly_reviews,\n    x='month_year',\n    y='review_count',\n    color='app_name',\n    markers=True,\n    title='Monthly Review Counts per App',\n    labels={\n        'month_year': 'Month-Year',\n        'review_count': 'Number of Reviews',\n        'app_name': 'App Name'\n    },\n    hover_name='app_name',\n    hover_data={'month_year': True, 'review_count': True}\n)\n\n# Beautify layout\nfig.update_layout(\n    xaxis_tickangle=-45,\n    width=1000,\n    height=600,\n    plot_bgcolor='white',\n    hovermode='x unified',\n    xaxis=dict(showgrid=True),\n    yaxis=dict(showgrid=True)\n)\n\n# Show plot\nfig.show()\n\n\n\n\n\nThis line chart illustrates the monthly trend in the number of customer reviews received by three major food delivery apps: UberEats, DoorDash, and GrubHub. The x-axis represents time in month-year format, while the y-axis shows the number of reviews submitted during each period. By tracking this timeline, the chart reveals seasonal patterns, spikes in user engagement, or dips in activity for each app. This visualization helps compare overall app popularity and review volume over time.\n\n\nCode\ndf_combined1 = df_combined.copy()\ndf_combined1['review_datetime'] = pd.to_datetime(df_combined1['review_datetime'], errors='coerce')\ndf_combined1['month_year'] = df_combined1['review_datetime'].dt.to_period('M').astype(str)\n\n# Group by data_source and month_year\nmonthly_reviews_source = df_combined1.groupby(['data_source', 'month_year']).size().reset_index(name='review_count')\n\n\n\nfig = px.line(\n    monthly_reviews_source,\n    x='month_year',\n    y='review_count',\n    color='data_source',\n    markers=True,\n    title='Monthly Review Counts per Data Source',\n    labels={\n        'month_year': 'Month-Year',\n        'review_count': 'Number of Reviews',\n        'data_source': 'Data Source'\n    },\n    hover_name='data_source',\n    hover_data={'month_year': True, 'review_count': True}\n)\n\nfig.update_layout(\n    xaxis_tickangle=-45,\n    width=1000,\n    height=600,\n    plot_bgcolor='white',\n    hovermode='x unified'\n)\n\nfig.show()\n\n\n\n\n\nThis line chart tracks the monthly volume of customer reviews submitted through different data sources: App Store, Google Play, and Reddit. The x-axis represents the timeline in month-year format, while the y-axis displays the number of reviews collected each month. This visualization reveals platform-specific trends in review activity, such as steady engagement from Google Play, increasing contributions from Reddit, and consistently lower volume from the App Store. It helps highlight how different platforms contribute to user feedback over time.\n\n\nCode\nreddit_reviews = df_combined[df_combined['data_source'] == 'Reddit']\n\n# Group by sentiment\nupvotes_by_sentiment = reddit_reviews.groupby('sentiment')['upvote_count'].mean()\n\n# Plot\nupvotes_by_sentiment.plot(kind='bar', figsize=(8,6), edgecolor='black')\nplt.title('Average Upvotes by Sentiment (Reddit Reviews)', fontsize=16)\nplt.ylabel('Average Upvote Count', fontsize=14)\nplt.xlabel('Sentiment', fontsize=14)\nplt.grid(axis='y')\nplt.xticks(rotation=0)\nplt.show()\n\n\n\n\n\n\n\n\n\nThe above bar plot visualizes how upvotes are related to sentiments of the user. Here the plot shows how many upvotes were there for a review under given snetiment( Negative, Positive, Neutral)\n\n\nCode\nplt.figure(figsize=(8,6))\nplt.scatter(reddit_reviews['total_comments'], reddit_reviews['upvote_count'], alpha=0.6)\nplt.title('Upvotes vs Total Comments for Reddit Reviews', fontsize=16)\nplt.xlabel('Total Comments', fontsize=14)\nplt.ylabel('Upvote Count', fontsize=14)\nplt.grid(True)\nplt.show()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Analyzing Customer Experience: Multi-Platform Review Analysis for Food Delivery Apps",
    "section": "",
    "text": "This project presents a comprehensive analysis of customer experiences across popular food delivery platforms, using user-generated reviews from multiple sources.\nWe explore natural language processing (NLP) techniques to understand what customers say about key aspects of service such as delivery time, app usability, food quality, and customer support. By leveraging pretrained models and modern text classification methods, we extract meaningful insights to support product improvement and competitive analysis.\n\n\n\nThis project investigates customer experiences with major food delivery platforms ‚Äî Uber Eats, DoorDash, and Grubhub ‚Äî by analyzing unstructured reviews from Reddit, the App Store, and Google Play. The analysis reveals that disappointment is the most commonly expressed emotion, particularly in App Store reviews for Grubhub and Uber Eats.\nNegative sentiment is largely tied to late or missing orders, delivery delays, app glitches, and unresponsive customer service. DoorDash also sees notable complaints about pricing issues.\nTopic modeling uncovered four dominant themes across reviews:\n1. Service quality problems\n2. Delivery inefficiencies\n3. App-related frustrations\n4. A smaller portion of positive feedback\nBased on these insights, we recommend targeted improvements in customer support, logistics, app usability, and pricing to boost user satisfaction and retention.\n\n\n\n\n\nAnalyze and visualize customer sentiment across multiple food delivery apps\n\nApply zero-shot classification to identify review topics without labeled data\n\nUse emotion and sentiment analysis to detect emotional tones in customer feedback\n\nPerform exploratory data analysis (EDA) to uncover review patterns and trends\n\nApply topic modeling to identify hidden themes in large text corpora\n\n\n\n\n\nExplore the full analysis by navigating through the sections below:\n\nüîç Zero-Shot Classification\nUse transformer models to classify reviews into topics without predefined training labels.\nüò† Emotion Analysis\nDetect the emotional undertone (joy, anger, fear, etc.) in customer reviews.\nüôÇ Sentiment Analysis\nClassify review polarity (positive, negative, neutral) using pretrained sentiment models.\nüìä Exploratory Data Analysis\nUnderstand review distributions, rating patterns, and platform-level trends.\nüß† Topic Modeling\nDiscover key themes in large text datasets using unsupervised learning (LDA/BERT).\n\n\n\n\n\nThis project was completed by Group 19 as part of MSDS 597 ‚Äì Data Wrangling at Rutgers University, Spring 2025."
  },
  {
    "objectID": "index.html#summary-of-findings",
    "href": "index.html#summary-of-findings",
    "title": "Analyzing Customer Experience: Multi-Platform Review Analysis for Food Delivery Apps",
    "section": "",
    "text": "This project investigates customer experiences with major food delivery platforms ‚Äî Uber Eats, DoorDash, and Grubhub ‚Äî by analyzing unstructured reviews from Reddit, the App Store, and Google Play. The analysis reveals that disappointment is the most commonly expressed emotion, particularly in App Store reviews for Grubhub and Uber Eats.\nNegative sentiment is largely tied to late or missing orders, delivery delays, app glitches, and unresponsive customer service. DoorDash also sees notable complaints about pricing issues.\nTopic modeling uncovered four dominant themes across reviews:\n1. Service quality problems\n2. Delivery inefficiencies\n3. App-related frustrations\n4. A smaller portion of positive feedback\nBased on these insights, we recommend targeted improvements in customer support, logistics, app usability, and pricing to boost user satisfaction and retention."
  },
  {
    "objectID": "index.html#objectives",
    "href": "index.html#objectives",
    "title": "Analyzing Customer Experience: Multi-Platform Review Analysis for Food Delivery Apps",
    "section": "",
    "text": "Analyze and visualize customer sentiment across multiple food delivery apps\n\nApply zero-shot classification to identify review topics without labeled data\n\nUse emotion and sentiment analysis to detect emotional tones in customer feedback\n\nPerform exploratory data analysis (EDA) to uncover review patterns and trends\n\nApply topic modeling to identify hidden themes in large text corpora"
  },
  {
    "objectID": "index.html#analysis-modules",
    "href": "index.html#analysis-modules",
    "title": "Analyzing Customer Experience: Multi-Platform Review Analysis for Food Delivery Apps",
    "section": "",
    "text": "Explore the full analysis by navigating through the sections below:\n\nüîç Zero-Shot Classification\nUse transformer models to classify reviews into topics without predefined training labels.\nüò† Emotion Analysis\nDetect the emotional undertone (joy, anger, fear, etc.) in customer reviews.\nüôÇ Sentiment Analysis\nClassify review polarity (positive, negative, neutral) using pretrained sentiment models.\nüìä Exploratory Data Analysis\nUnderstand review distributions, rating patterns, and platform-level trends.\nüß† Topic Modeling\nDiscover key themes in large text datasets using unsupervised learning (LDA/BERT)."
  },
  {
    "objectID": "index.html#group-19",
    "href": "index.html#group-19",
    "title": "Analyzing Customer Experience: Multi-Platform Review Analysis for Food Delivery Apps",
    "section": "",
    "text": "This project was completed by Group 19 as part of MSDS 597 ‚Äì Data Wrangling at Rutgers University, Spring 2025."
  },
  {
    "objectID": "notebooks/Emotion_Analysis.html",
    "href": "notebooks/Emotion_Analysis.html",
    "title": "Emotion Analysis of Reviews",
    "section": "",
    "text": "Device set to use cuda:0\nProcessing 126725 reviews in 3961 batches...\nToken indices sequence length is longer than the specified maximum sequence length for this model (518 &gt; 512). Running this sequence through the model will result in indexing errors\n\n\nFound 397 reviews longer than the maximum token length of 512.\nThese reviews will be automatically truncated during processing.\n\n\n\n\n\nYou seem to be using the pipelines sequentially on GPU. In order to maximize efficiency please use a dataset"
  },
  {
    "objectID": "notebooks/Emotion_Analysis.html#average-emotion-scores-across-all-reviews",
    "href": "notebooks/Emotion_Analysis.html#average-emotion-scores-across-all-reviews",
    "title": "Emotion Analysis of Reviews",
    "section": "Average emotion scores across all reviews",
    "text": "Average emotion scores across all reviews\n\n\n\nAverage emotion scores across all reviews:\ndisappointment    0.072520\nexcitement        0.041951\nrelief            0.038141\njoy               0.030576\noptimism          0.025321\nsadness           0.020504\nnervousness       0.018222\nfear              0.012035\nanxiety           0.000000\nhope              0.000000\nworry             0.000000\ndread             0.000000\nconfidence        0.000000\ndtype: float64"
  },
  {
    "objectID": "notebooks/Emotion_Analysis.html#average-emotion-scores-across-reviews",
    "href": "notebooks/Emotion_Analysis.html#average-emotion-scores-across-reviews",
    "title": "Emotion Analysis of Reviews",
    "section": "Average Emotion Scores Across Reviews",
    "text": "Average Emotion Scores Across Reviews\n\n\nCode\n#Bar plot for average emotion scores across reviews\nplt.figure(figsize=(12, 6))\nsns.barplot(x=avg_emotions.index, y=avg_emotions.values,palette='Set2')\nplt.xticks(rotation=45, ha='right')\nplt.title('Average Emotion Scores Across Reviews')\nplt.xlabel('Emotion')  # &lt;-- added x-axis label here\nplt.ylabel('Average Score')\nplt.tight_layout()\nplt.show()\n\n\nFutureWarning: \n\nPassing `palette` without assigning `hue` is deprecated and will be removed in v0.14.0. Assign the `x` variable to `hue` and set `legend=False` for the same effect.\n\n  sns.barplot(x=avg_emotions.index, y=avg_emotions.values,palette='Set2')\n\n\n\n\n\n\n\n\n\nDisappointment is the most prominent emotion, indicating a generally unsatisfactory customer experience. While positive emotions like excitement, relief, and joy appear next, their scores lag behind, showing mixed but leaning-negative sentiment."
  },
  {
    "objectID": "notebooks/Emotion_Analysis.html#emotion-scores-by-app-rating",
    "href": "notebooks/Emotion_Analysis.html#emotion-scores-by-app-rating",
    "title": "Emotion Analysis of Reviews",
    "section": "Emotion Scores by App Rating",
    "text": "Emotion Scores by App Rating\n\n\nCode\n# Analyze emotions by app rating (if app_rating column exists)\nif 'app_rating' in result_df.columns:\n    print(\"\\nAnalyzing emotions by app rating...\")\n\n    # Step 1: Group by rating and calculate average emotion scores\n    emotions_by_rating = result_df.groupby('app_rating')[emotion_cols].mean()\n\n    # Step 2: Remove columns where all values are zero\n    emotions_by_rating = emotions_by_rating.loc[:, (emotions_by_rating != 0).any(axis=0)]\n\n    # Plot heatmap\n    plt.figure(figsize=(14, 8))\n    sns.heatmap(emotions_by_rating, cmap='YlGnBu', annot=True, fmt='.2f')\n    plt.title('Emotion Scores by App Rating')\n    plt.xlabel('Emotion')\n    plt.ylabel('App Rating')\n    plt.tight_layout()\n    plt.show()\n\n\n\nAnalyzing emotions by app rating...\n\n\n\n\n\n\n\n\n\nThe heatmap clearly shows that disappointment is strongly associated with low ratings (1‚Äì2 stars), while positive emotions like excitement, joy, and relief become more prominent in higher-rated reviews (4‚Äì5 stars). This trend highlights that emotional tone closely mirrors customer satisfaction levels, with disappointment being a key indicator of negative app experiences.\n\n\n\nDominant emotion counts:\ndominant_emotion\ndisappointment    58007\nexcitement        24286\nrelief            24275\njoy               13105\noptimism           2951\nnervousness        2813\nsadness             982\nfear                306\nName: count, dtype: int64"
  },
  {
    "objectID": "notebooks/Emotion_Analysis.html#dominant-emotions-in-reviews",
    "href": "notebooks/Emotion_Analysis.html#dominant-emotions-in-reviews",
    "title": "Emotion Analysis of Reviews",
    "section": "Dominant Emotions in Reviews",
    "text": "Dominant Emotions in Reviews\n\n\nCode\n#Dominant emotions in reviews bar plot\nplt.figure(figsize=(10, 6))\nsns.barplot(x=emotion_counts.index, y=emotion_counts.values, palette='Set2')\nplt.title('Dominant Emotions in Reviews')\nplt.ylabel('Count')\nplt.xlabel('Emotion')\nplt.xticks(rotation=45, ha='right')\nplt.tight_layout()\nplt.show()\n\n\nFutureWarning: \n\nPassing `palette` without assigning `hue` is deprecated and will be removed in v0.14.0. Assign the `x` variable to `hue` and set `legend=False` for the same effect.\n\n  sns.barplot(x=emotion_counts.index, y=emotion_counts.values, palette='Set2')\n\n\n\n\n\n\n\n\n\nDisappointment is the dominant emotion in the majority of reviews, significantly outpacing all other emotional categories. Excitement and relief also appear frequently, suggesting some positive experiences. However, the imbalance highlights that customer dissatisfaction is a core theme across feedback platforms"
  },
  {
    "objectID": "notebooks/Emotion_Analysis.html#emotion-scores-by-app",
    "href": "notebooks/Emotion_Analysis.html#emotion-scores-by-app",
    "title": "Emotion Analysis of Reviews",
    "section": "Emotion Scores by App",
    "text": "Emotion Scores by App\n\n\nCode\n# Analyze emotions by app name (if app_name column exists)\nif 'app_name' in result_df.columns and len(result_df['app_name'].unique()) &gt; 1:\n    print(\"\\nAnalyzing emotions by app name...\")\n\n    # Step 1: Group by app name and calculate average emotion scores\n    app_emotions = result_df.groupby('app_name')[emotion_cols].mean()\n\n    # Step 2: Remove columns where all values are zero\n    app_emotions = app_emotions.loc[:, (app_emotions != 0).any(axis=0)]\n\n    # Step 3: Plot heatmap\n    plt.figure(figsize=(16, 10))\n    sns.heatmap(app_emotions, cmap='YlGnBu', annot=True, fmt='.2f')\n    plt.title('Emotion Scores by App')\n    plt.xlabel('Emotion')\n    plt.ylabel('App Name')\n    plt.tight_layout()\n    plt.show()\n\n\n\n\nAnalyzing emotions by app name...\n\n\n\n\n\n\n\n\n\nDisappointment is the leading emotion across DoorDash, Grubhub, and UberEats, with Grubhub and UberEats displaying slightly higher levels. Positive emotions like excitement, joy, and relief appear consistently but are less dominant. This indicates a shared challenge across platforms in fully meeting customer expectations."
  },
  {
    "objectID": "notebooks/Emotion_Analysis.html#most-dynamic-emotions-over-time",
    "href": "notebooks/Emotion_Analysis.html#most-dynamic-emotions-over-time",
    "title": "Emotion Analysis of Reviews",
    "section": "Most Dynamic Emotions Over Time",
    "text": "Most Dynamic Emotions Over Time\n\n\nCode\n# Analyze emotions over time if datetime column exists\nif 'review_datetime' in result_df.columns:\n    try:\n        print(\"\\nAnalyzing emotions over time...\")\n        # Convert to datetime if it's not already\n        if not pd.api.types.is_datetime64_any_dtype(result_df['review_datetime']):\n            result_df['review_datetime'] = pd.to_datetime(result_df['review_datetime'], errors='coerce')\n\n        # Create a month column for grouping\n        result_df['month'] = result_df['review_datetime'].dt.to_period('M')\n\n        # Group by month and calculate average emotion scores\n        monthly_emotions = result_df.groupby('month')[emotion_cols].mean()\n\n        # Remove emotions with all zero values\n        monthly_emotions = monthly_emotions.loc[:, (monthly_emotions != 0).any(axis=0)]\n\n        # Convert 'month' to timestamp\n        monthly_emotions.index = monthly_emotions.index.to_timestamp()\n\n        # ‚ú® NEW: Select only emotions with highest variability (standard deviation)\n        emotion_std = monthly_emotions.std().sort_values(ascending=False)\n        top_emotions = emotion_std.head(5).index  # Pick top 5 emotions with most variation\n\n        # Filter to only those emotions\n        monthly_emotions = monthly_emotions[top_emotions]\n\n        # Reshape data for seaborn\n        monthly_emotions_long = monthly_emotions.reset_index().melt(id_vars='month', var_name='Emotion', value_name='Average Score')\n\n        # Plot using Seaborn\n        plt.figure(figsize=(20, 10))\n        sns.lineplot(data=monthly_emotions_long, x='month', y='Average Score', hue='Emotion', marker='o')\n\n        plt.title('Most Dynamic Emotions Over Time')\n        plt.ylabel('Average Score')\n        plt.xlabel('Month')\n        plt.xticks(rotation=45, ha='right')\n        plt.grid(True, linestyle='--', alpha=0.7)\n        plt.legend(title='Emotion', bbox_to_anchor=(1.05, 1), loc='upper left')\n        plt.tight_layout()\n        plt.show()\n\n    except Exception as e:\n        print(f\"Could not create emotions over time chart: {e}\")\n\n\n\nAnalyzing emotions over time...\n\n\n\n\n\n\n\n\n\nDisappointment consistently remains the dominant emotion over time, peaking sharply around September 2024. Positive emotions such as relief, joy, and optimism decline steadily after mid-2024, suggesting a gradual deterioration in user satisfaction. Excitement shows relatively stable trends throughout the period."
  },
  {
    "objectID": "notebooks/Emotion_Analysis.html#heatmap-for-emotion-scores-by-data-source",
    "href": "notebooks/Emotion_Analysis.html#heatmap-for-emotion-scores-by-data-source",
    "title": "Emotion Analysis of Reviews",
    "section": "Heatmap for Emotion Scores by Data Source",
    "text": "Heatmap for Emotion Scores by Data Source\n\n\nCode\n# Analyze emotions by data source if 'data_source' column exists\nif 'data_source' in result_df.columns:\n    try:\n        print(\"\\nAnalyzing emotions by data source...\")\n\n        # Group by data_source and calculate average emotion scores\n        source_emotions = result_df.groupby('data_source')[emotion_cols].mean()\n\n        # Remove emotions with all zero values\n        source_emotions = source_emotions.loc[:, (source_emotions != 0).any(axis=0)]\n\n        # ‚ú® Select most dynamic emotions (optional: top 5 by std deviation)\n        emotion_std = source_emotions.std().sort_values(ascending=False)\n        top_emotions = emotion_std.head(5).index\n\n        # Filter only top emotions\n        source_emotions = source_emotions[top_emotions]\n\n        # Plot heatmap\n        plt.figure(figsize=(14, 8))\n        sns.heatmap(source_emotions, cmap='YlGnBu', annot=True, fmt='.2f')\n\n        plt.title('Emotion Scores by Data Source')\n        plt.xlabel('Emotion')\n        plt.ylabel('Data Source')\n        plt.tight_layout()\n        plt.show()\n\n    except Exception as e:\n        print(f\"Could not create emotion comparison heatmap: {e}\")\n\n\n\nAnalyzing emotions by data source...\n\n\n\n\n\n\n\n\n\nDisappointment is most pronounced in App Store reviews, indicating a higher level of dissatisfaction compared to Google Play and Reddit. Google Play reviews show a more balanced emotional spread, while Reddit displays lower overall emotional intensity. This highlights that App Store feedback tends to be more emotionally charged and negative."
  },
  {
    "objectID": "notebooks/Emotion_Analysis.html#bar-plot-for-emotion-scores-by-app-and-data-source",
    "href": "notebooks/Emotion_Analysis.html#bar-plot-for-emotion-scores-by-app-and-data-source",
    "title": "Emotion Analysis of Reviews",
    "section": "Bar Plot for Emotion Scores by App and Data Source",
    "text": "Bar Plot for Emotion Scores by App and Data Source\n\n\nCode\n# Analyze emotions by app and data source\nif 'app_name' in result_df.columns and 'data_source' in result_df.columns:\n    try:\n        print(\"\\nAnalyzing emotions by App and Data Source (Bar Plot)...\")\n\n        # Group by both app_name and data_source\n        app_source_emotions = result_df.groupby(['app_name', 'data_source'])[emotion_cols].mean()\n\n        # Remove emotions with all zero values\n        app_source_emotions = app_source_emotions.loc[:, (app_source_emotions != 0).any(axis=0)]\n\n        # ‚ú® Select top varying emotions (optional: top 5)\n        emotion_std = app_source_emotions.std().sort_values(ascending=False)\n        top_emotions = emotion_std.head(5).index\n\n        # Filter only top emotions\n        app_source_emotions = app_source_emotions[top_emotions]\n\n        # Reset index to make it plottable\n        app_source_emotions = app_source_emotions.reset_index()\n\n        # Create one combined label for app and data source\n        app_source_emotions['App_Source'] = app_source_emotions['app_name'] + ' (' + app_source_emotions['data_source'] + ')'\n\n        # Melt the dataframe for seaborn plotting\n        app_source_long = app_source_emotions.melt(id_vars='App_Source', value_vars=top_emotions,\n                                                   var_name='Emotion', value_name='Average Score')\n\n        # Plot\n        plt.figure(figsize=(20, 10))\n        sns.barplot(data=app_source_long, x='App_Source', y='Average Score', hue='Emotion')\n\n        plt.title('Emotion Scores by App and Data Source')\n        plt.xlabel('App (Data Source)')\n        plt.ylabel('Average Emotion Score')\n        plt.xticks(rotation=45, ha='right')\n        plt.legend(title='Emotion', bbox_to_anchor=(1.05, 1), loc='upper left')\n        plt.tight_layout()\n        plt.show()\n\n    except Exception as e:\n        print(f\"Could not create combined bar plot: {e}\")\n\n\n\nAnalyzing emotions by App and Data Source (Bar Plot)..."
  },
  {
    "objectID": "notebooks/Emotion_Analysis.html#heatmap-for-emotion-scores-across-apps-and-data-sources",
    "href": "notebooks/Emotion_Analysis.html#heatmap-for-emotion-scores-across-apps-and-data-sources",
    "title": "Emotion Analysis of Reviews",
    "section": "Heatmap for Emotion Scores Across Apps and Data Sources",
    "text": "Heatmap for Emotion Scores Across Apps and Data Sources\n\n\nCode\n# Analyze emotions by app and data source -  Heatmap\nif 'app_name' in result_df.columns and 'data_source' in result_df.columns:\n    try:\n        print(\"\\nAnalyzing emotions by App and Data Source (Simple Heatmap)...\")\n\n        # Group by both app_name and data_source\n        app_source_emotions = result_df.groupby(['app_name', 'data_source'])[emotion_cols].mean()\n\n        # Remove emotions with all zero values\n        app_source_emotions = app_source_emotions.loc[:, (app_source_emotions != 0).any(axis=0)]\n\n        # ‚ú® Select top varying emotions (optional: top 5)\n        emotion_std = app_source_emotions.std().sort_values(ascending=False)\n        top_emotions = emotion_std.head(5).index\n\n        # Filter only top emotions\n        app_source_emotions = app_source_emotions[top_emotions]\n\n        # Create one combined label for app and data source\n        app_source_emotions = app_source_emotions.reset_index()\n        app_source_emotions['App_Source'] = app_source_emotions['app_name'] + ' (' + app_source_emotions['data_source'] + ')'\n\n        # Now pivot the table: Emotion (rows) √ó App_Source (columns)\n        pivot_table = app_source_emotions.melt(id_vars=['App_Source'], value_vars=top_emotions,\n                                               var_name='Emotion', value_name='Average Score')\n        pivot_table = pivot_table.pivot(index='Emotion', columns='App_Source', values='Average Score')\n\n        # Plot heatmap\n        plt.figure(figsize=(18, 10))\n        sns.heatmap(pivot_table, cmap='YlGnBu', annot=True, fmt='.2f')\n\n        plt.title('Emotion Scores Across Apps and Data Sources')\n        plt.xlabel('App (Data Source)')\n        plt.ylabel('Emotion')\n        plt.xticks(rotation=45, ha='right')\n        plt.tight_layout()\n        plt.show()\n\n    except Exception as e:\n        print(f\"Could not create simple heatmap: {e}\")\n\n\n\nAnalyzing emotions by App and Data Source (Simple Heatmap)...\n\n\n\n\n\n\n\n\n\nDisappointment clearly dominates customer emotions across all apps and platforms, especially for Grubhub and UberEats on the App Store. Google Play reviews display more emotional diversity, while Reddit feedback remains relatively muted. This reinforces that App Store reviews tend to reflect stronger dissatisfaction"
  },
  {
    "objectID": "notebooks/Topic Modeling.html",
    "href": "notebooks/Topic Modeling.html",
    "title": "Topic Modeling of Reviews",
    "section": "",
    "text": "C:\\Users\\16096\\Documents\\KAJAL\\Semester2\\Data Wrangling\\Projects-HW\\dwproj_new\\Lib\\site-packages\\requests\\__init__.py:89: RequestsDependencyWarning: urllib3 (1.26.18) or chardet (3.0.4) doesn't match a supported version!\n  warnings.warn(\"urllib3 ({}) or chardet ({}) doesn't match a supported \"\n[nltk_data] Downloading package punkt_tab to\n[nltk_data]     C:\\Users\\16096\\AppData\\Roaming\\nltk_data...\n[nltk_data]   Package punkt_tab is already up-to-date!\n(126725, 8)\n\n\n\n\n\n\n\n\n\nreview\nreview_datetime\ndata_source\napp_name\nupvote_count\ntotal_comments\napp_rating\nsentiment\n\n\n\n\n0\nuber eats for owls? will they ever come out wi...\n2025-04-20 21:51:15\nReddit\nUberEats\n1.0\n2.0\nNaN\nNeutral\n\n\n1\nserious question yall is it worth going out to...\n2025-04-20 21:41:21\nReddit\nUberEats\n1.0\n1.0\nNaN\nNeutral\n\n\n2\nubereats charged me for a successful chargebac...\n2025-04-20 20:50:04\nReddit\nUberEats\n1.0\n2.0\nNaN\nNegative\n\n\n3\nubereats driver scammed me by buying half the ...\n2025-04-20 20:48:13\nReddit\nUberEats\n1.0\n9.0\nNaN\nNegative\n\n\n4\nubereats why you do this? family went out of t...\n2025-04-20 20:19:15\nReddit\nUberEats\n1.0\n3.0\nNaN\nNegative\nFound 3 unique apps: UberEats, DoorDash, GrubHub"
  },
  {
    "objectID": "notebooks/Topic Modeling.html#coherence-score-vs-number-of-topics",
    "href": "notebooks/Topic Modeling.html#coherence-score-vs-number-of-topics",
    "title": "Topic Modeling of Reviews",
    "section": "Coherence Score vs Number of Topics",
    "text": "Coherence Score vs Number of Topics\n\n\nCode\nfor app in unique_apps:\n    print(f\"\\nProcessing app: {app}\")\n    app_reviews = df[df['app_name'] == app]['review']\n\n    processed_reviews = preprocess_reviews(app_reviews)\n    #print(len(processed_reviews))\n    coherence_scores, models = compute_coherence_values(processed_reviews, start=2, limit=20, step=1)\n    plot_coherence_scores(coherence_scores, app_name=app)\n\n    best_num_topics, best_score = max(coherence_scores, key=lambda x: x[1])\n    print(f\"Best number of topics for {app}: {best_num_topics} with coherence score {best_score:.4f}\")\n\n    for num, model, corpus, dictionary in models:\n        if num == best_num_topics:\n            best_model, best_corpus, best_dictionary = model, corpus, dictionary\n            break\n\n    visualize_topics_pyldavis(best_model, best_corpus, best_dictionary, app_name=app)\n\nprint(\"\\n‚úÖ All Apps Processed Successfully!\")\n\n\n\nProcessing app: UberEats\nPreprocessing reviews...\nCompleted preprocessing 64153 reviews.\nComputing coherence scores...\nTraining LDA with 2 topics...\nTraining LDA with 3 topics...\nTraining LDA with 4 topics...\nTraining LDA with 5 topics...\nTraining LDA with 6 topics...\nTraining LDA with 7 topics...\nTraining LDA with 8 topics...\nTraining LDA with 9 topics...\nTraining LDA with 10 topics...\nTraining LDA with 11 topics...\nTraining LDA with 12 topics...\nTraining LDA with 13 topics...\nTraining LDA with 14 topics...\nTraining LDA with 15 topics...\nTraining LDA with 16 topics...\nTraining LDA with 17 topics...\nTraining LDA with 18 topics...\nTraining LDA with 19 topics...\nTraining LDA with 20 topics...\nCompleted coherence score calculation.\n\n\n\n\n\n\n\n\n\nBest number of topics for UberEats: 15 with coherence score 0.5595\nPreparing pyLDAvis visualization for UberEats...\nSaved pyLDAvis visualization to UberEats_topics.html üöÄ\n\nProcessing app: DoorDash\nPreprocessing reviews...\nCompleted preprocessing 53719 reviews.\nComputing coherence scores...\nTraining LDA with 2 topics...\nTraining LDA with 3 topics...\nTraining LDA with 4 topics...\nTraining LDA with 5 topics...\nTraining LDA with 6 topics...\nTraining LDA with 7 topics...\nTraining LDA with 8 topics...\nTraining LDA with 9 topics...\nTraining LDA with 10 topics...\nTraining LDA with 11 topics...\nTraining LDA with 12 topics...\nTraining LDA with 13 topics...\nTraining LDA with 14 topics...\nTraining LDA with 15 topics...\nTraining LDA with 16 topics...\nTraining LDA with 17 topics...\nTraining LDA with 18 topics...\nTraining LDA with 19 topics...\nTraining LDA with 20 topics...\nCompleted coherence score calculation.\n\n\n\n\n\n\n\n\n\nBest number of topics for DoorDash: 6 with coherence score 0.5708\nPreparing pyLDAvis visualization for DoorDash...\nSaved pyLDAvis visualization to DoorDash_topics.html üöÄ\n\nProcessing app: GrubHub\nPreprocessing reviews...\nCompleted preprocessing 8844 reviews.\nComputing coherence scores...\nTraining LDA with 2 topics...\nTraining LDA with 3 topics...\nTraining LDA with 4 topics...\nTraining LDA with 5 topics...\nTraining LDA with 6 topics...\nTraining LDA with 7 topics...\nTraining LDA with 8 topics...\nTraining LDA with 9 topics...\nTraining LDA with 10 topics...\nTraining LDA with 11 topics...\nTraining LDA with 12 topics...\nTraining LDA with 13 topics...\nTraining LDA with 14 topics...\nTraining LDA with 15 topics...\nTraining LDA with 16 topics...\nTraining LDA with 17 topics...\nTraining LDA with 18 topics...\nTraining LDA with 19 topics...\nTraining LDA with 20 topics...\nCompleted coherence score calculation.\n\n\n\n\n\n\n\n\n\nBest number of topics for GrubHub: 4 with coherence score 0.5687\nPreparing pyLDAvis visualization for GrubHub...\nSaved pyLDAvis visualization to GrubHub_topics.html üöÄ\n\n‚úÖ All Apps Processed Successfully!"
  }
]